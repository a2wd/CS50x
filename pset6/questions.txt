0.  Pneumonoultramicroscopicsilicovolcanoconiosis, or P45 (as it has 45 letters) is the longest word in the English language, an artificial word made up to be the longest in the dictionary and which refers to a lung disease.
1.  "getrusage" measures the amount of system resources used by a process (or it's children) and returns a struct containing information on this usage, such as system/user CPU cycles, block IO operations, stack, memory and data size.
2.  There are 16 variables in a struct of type rusage, although the first two of these are structs themselves which each contain two variables: time_t and suseconds_t (as per sys/time.h).
3.  The before and after structs are passed by reference since this is quicker and more efficient than creating a copy of the variables.
4.  The for loop in Main works by iterating throught the text (passed via the command line) character by character with fgetc(), reading into the word array while the character passed is numeric or an apostraphe (unless the apostraphe falls at the beginning of a word). In the case of a number or a string longer than the maximum allowed word length, the program reads characters without storing them, until the next word is encountered and sets the index to 0 to begin a new word in the word[] array. The final else if() in the for loop is hit when there is a blank space and checks that there is indeed a word stored in the word[] array (by index being greater than 0). It adds the terminating '\0' character to the word, sends it to check() to see if it is spelled correctly and prepares for the next word by settting the index back to 0. In the case of a misspelled word, this is printed onscreen and the misspellings counter is incremented by 1.
5.  fgetc() was used over fscanf() because the %s specifier doesn't check for length or whether the string contains non alphabetical characters.
6.  By declaring the pointers passed to check() and load() as const, the values the pointers point to cannot be changed (that is, the value of the word[] array from main or the dictionary file address). This was done to reinforce that these values shouldn't be modified (e.g., In the instance of the word[] array, capitalisations should not be taken care of by changing the word array as it is also used to print the misspelled word as read in from file).
7.  To implement the speller program, I used a trie data structure. Each node in the trie consisted of an array of 27 node pointers to the next level (a-z and apostrophe) and a boolean variable to record whether a word ended at that node.
8.  The first time I got it working, the code ran very quickly (0.12sec).
9.  To improve its performance, I changed how I was transforming the a-z and apostrophe word mapping to an element in the node array, from working with an intermediate char to directly calculating it as it was accessed.
10. The code is half the speed of the staff's implementation and I think, given more time a lot of changes could be made to streamline it, especially my use of intermediate variables instead of using more pointer manipulation.
